
simplify the life
闭包初窥
　　不久前的面试中，面试官开门见山问我闭包是什么，我哑然。就像this一样，可能给我几道关于this的题目我会做，但是要我说说什么是this，我还真不知道从何说起，为了face以后同样的问题，查阅了一些资料在此简单做下记录。诚然，楼主对于闭包的理解还处在初级阶段...

　　简单来说闭包拥有三个特性：

1.函数嵌套函数
2.函数内部可以引用外部的参数和变量
3.参数和变量不会被垃圾回收机制回收

　　闭包是指有权访问另一个函数作用域中的变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量。使用闭包有一个优点，也是它的缺点，就是可以把局部变量驻留在内存中，可以避免使用全局变量。全局变量在每个模块都可调用，这势必将是灾难性的。（所以推荐使用私有的，封装的局部变量。）一般函数执行完毕后，局部活动对象就被销毁，内存中仅仅保存全局作用域。但闭包的情况不同！

　　我觉得这段说明也很精彩：js里的函数在运行结束之后，所有的过程中产生的变量都会被销毁（销毁原则是无引用）
但在js的函数A里定义一个函数B并在外部引用时，这条引用链上的变量都不会销毁（即使A已经运行结束），这个函数B就叫做一个闭包。

复制代码
function fn() {
  var a = 0;
  function f() {
    console.log(a++);
  }
  return f;
}

var b = fn();
b();  // 0
b();  // 1
b();  // 2
复制代码
　　接着来看上面的例子，这是一段经典的闭包代码，我们看看代码都干了些什么。

　　首先要明确f函数即是所谓的闭包，我们看到它嵌套在fn函数内，而且访问了外部的变量a，同时console的结果也证明了变量a贮存在了内存中！为什么会这样呢？原因在于f被赋予给了一个全局变量b，导致始终存在在内存中，而f的存在必须依赖于fn，这导致fn也始终存在在内存中，于是变量a不会在执行后被垃圾回收机制回收。以上例子很好地避免了全局变量的使用，避免了全局变量的污染。

　　闭包还有什么用？继续一个经典的例子：

复制代码
<ul>
  <li>0</li>
  <li>1</li>
  <li>2</li>
  <li>3</li>
  <li>4</li>
</ul>
<script>
  var lis = document.getElementsByTagName('li');
  for(var i = 0; i < lis.length; i++) {
    ~function(i) {
      lis[i].onclick = function() {
        alert(i)
      };
    }(i)
  }
</script>
复制代码
　　我们都知道不使用闭包的话，每个li弹出的数字会是一样的，这时的闭包就能把i的值储存在内存中。

　　闭包还可用于模块化代码，减少全局变量的污染：

复制代码
var abc = (function(){ //abc为外部匿名函数的返回值
  var a = 1;
  return function(){
    a++;
    alert(a);
  }
})();

abc(); //2     
abc(); //3
复制代码
　　闭包还可用于设置私有成员

var obj = function(){
  var num = 0;
  function a() {
    num++;
    return num;
  }

  function b() {
    num++;
    return num;
  }

  return {
    a: a,
    b: b
  }
}();

console.log(obj.a()); // 1
console.log(obj.b()); // 2
　这样就无法修改num的值了，保护了私有成员。

　　个人感觉闭包和立即执行函数有着剪不断理还乱的关系啊...

　　楼主对于闭包的理解暂时到这里了，如有不对或者补充之处还望留言~